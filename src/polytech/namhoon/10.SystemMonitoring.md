---
layout : home
---



# 시스템 모니터링



### 【시스템 모니터링의 목적】



**1) 시스템의 빠른 장애 탐지 :** 모니터링의 가장 기본적인 목적은 시스템의 상태를 빠르게 파악하는 것이다. 이때는 사전또는 사후 관리를 위한 지표를 설정하고 빠르게 상태를 감지하는 것이 중요하다. 



**2) 서비스의 다운타임의 최소화 :** 빠른 장애 탐지를 통해 획득한 다양한 정보와 통계정보를 통해 서비스 복원을 수행하는 것이다. 이때  다양한 데이터 수집과 쉽게 상태 파악이 가능한 Dash Board나 검색 기능이 필요하다.



**3) 의사결정에 도움을 주는 것 :** 현재 상태에 대한 정보를 쉽게 파악하도록 시각화해 제공하고, 수집된 데이터의 의미를 파악하고 올바른 기준을 설정하도록 하여야 한다. 데이터는 단순한 장애 모니터링 뿐아니라 시스템의 증설이나 성능개선을 전.후를 파악하여 올바른 방향을 수립하도록 해야 한다.



**4) 운영 자동화 :** 운영 자동화란 장애가 발생했을 때 알림이나 장애 처리를 위한 룰을 적용해서 빠르게 상황에 대처하도록 서비스 복원을 자동화하기 위한 것이다. 특히 클라우드 같은 시스템을 자동 증설이나 축소를 자동화하여 시스템의 성능과 비용을 최적화 한다. 최근에는 인공지능 기술을 활용하여 시스템의 장애나 위협 상황을 사전 감지하는 것도 가능하다.



![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc2fybY%2FbtqPfSrA0HE%2FgzXtHNcpmMX1JUNYFsUPK1%2Fimg.jpg)





## 시스템 측정

리눅스 운영체제에서 시스템 측정(System monitoring)은 시스템 자원(CPU, 메모리, 디스크 등)의 사용률과 성능, 네트워크 연결 상태 등의 정보를 지속적으로 수집하여 분석하는 작업을 말합니다. 시스템 측정을 통해 시스템의 안정성, 성능, 문제점 등을 파악하여 문제점을 해결하고 최적화된 시스템 운영을 할 수 있습니다.

대표적인 시스템 측정 도구로는 top, vmstat, iostat, netstat, sar 등이 있습니다.



## 1.**Top** : <u>현재</u> CPU에 수행되고 있는 프로세스 상황을 CPU 자원을 많이 사용하는 순서대로 보여줌

시스템 전반적인 값(CPU/메모리)을 쉽게 확인할 수 있음

다만, 화면이 지속적으로 바뀜 (디폴트 업데이트시간 : 3초)

ps는 현 시점에 대한 프로세스 모니터링, top은 실시간 모니터링

 

## **실행 후 옵션**

| **Shift + p** | **CPU 사용률(%CPU) 큰 순서로 정렬**             |
| ------------- | ----------------------------------------------- |
| **Shift + m** | **메모리 사용률(%MEM) 큰 순서로 정렬**          |
| Shift + t     | 실행시간이 큰 순서로 정렬                       |
| K             | process 종료  이후 -9 죽일 프로세스ID(PID) 입력 |

## **해석**

![img](https://k.kakaocdn.net/dn/xyX6g/btqD2bJJdhy/2ClFbxQrOLGszym8FRH5PK/img.png)

 

현재 서버시간 / user 수 / 부하율

task 정보

| Top          | 현재 서버의 시간                                             |
| ------------ | ------------------------------------------------------------ |
| User         | 2 users : 2명의 사용자가 접속                                |
| Load average | 부하율 **1분, 5분, 15분 간의 평균 실행/대기 중인 프로세스의 수** |
| Task         | 전체 가동 중인 프로세스 개수 Running : 실행중인 프로세스 Sleeping : 대기중인 프로세스  Stopped : 멈춘 프레세스 Zombie : 좀비상태인 프로세스 |

CPU 정보

| %us  | 유저 레벨에서 사용하는cpu비중                                |
| ---- | ------------------------------------------------------------ |
| %sy  | 시스템 레벨애서 사용하는 cpu비중                             |
| %id  | 유휴상태의 cpu비중                                           |
| %wa  | 시스템 io 요청을 처리하지 못한 상태에서 cpu idle 상태인 비중 |

메모리 정보

| Total      | 전체 물리적인 메모리     |
| ---------- | ------------------------ |
| Free       | 사용되지 않은 여유메모리 |
| Used       | 사용중인 메모리          |
| Buff/cache | 버퍼된 메모리            |

프로세스정보

| PID     | 프로세스ID                                                   |
| ------- | ------------------------------------------------------------ |
| USER    | 프로세스를 실행시킨 사용자ID                                 |
| NI      | NICE값(마이너스면 우선순위높은 일)                           |
| S       | 프로세스의 상태 S : sleeping R : Running W : swapped out process z : zombies |
| %CPU    | 프로세스가 사용하는 CPU의 사용률                             |
| %MEM    | 프로세스가 사용하는 메모리의 사용률                          |
| COMMAND | 실행된 명령어                                                |



# 2. vmstat : 가상 메모리 통계 정보 확인( CPU / 메모리 / IO)현재 메모의 상태 출력

시스템 전반적인 값(CPU/메모리/IO)을 top보다 요약된 정보로 쉽게 확인할 수 있음

 

## **옵션**

| -a (active)       | buffer와 cache대신 active/inactivate로 메모리사용량 결과 출력 |
| ----------------- | ------------------------------------------------------------ |
| -t (timestamp)    | 날짜 + 시간을 출력                                           |
| -w (wide)         | 출력결과의 너비를 맞춤                                       |
| -d (disk)         | 디스크 상태조회                                              |
| [간격] [반복횟수] | vmstat 2 5 : 2초간격으로 5번 출력                            |

 

## 해석



![img](https://blog.kakaocdn.net/dn/mofSb/btqD1Ohkkxb/oRlpkYGQPoTyObcKOCYcTK/img.png)1초 간격으로 출력



**procs 필드**

| r (run)   | 현재 실행중인 프로세스 중 (cpu에 접근대기중인 프로세스) |
| --------- | ------------------------------------------------------- |
| b (block) | io자원을 할당받지 못해서 블록된 프로세스 수             |

**memory필드**

| swpd  | 사용된 가상 메모리 용량         |
| ----- | ------------------------------- |
| free  | 사용가능한 여유메모리 용량      |
| buff  | 버퍼에 사용된 메모리 용량       |
| cache | 페이지캐시에 사용된 메모리 용량 |

**swap 필드**

| si (swap-in)  | swap-in 된 메모리양                                          |
| ------------- | ------------------------------------------------------------ |
| so (swap-out) | swap-out 된 메모리양 ***(지속적으로 발생하면 메모리 부족)\*** |

**io 필드**

| bi (block input)  | 블록 디바이스로부터 입력된 블록수 |
| ----------------- | --------------------------------- |
| bo (block output) | 블록 디바이스로부터 쓰기된 블록수 |

**system 필드**

| in (interrupts)       | 초당 발생할 interrupts의 수              |
| --------------------- | ---------------------------------------- |
| cs (context switches) | 초당 발생한 context switchs(문맥교환) 수 |

**CPU필드** 

| us (user)   | CPU가 user level의 코드를 실행한 시간(단위%) -> 사용자 영역에서 사용하는 CPU의 비율 *us의 CPU가 높을 경우 : OS명령어로 알기 어렵다.* |
| ----------- | ------------------------------------------------------------ |
| sy (system) | CPU가 system level의 코드를 실행한 시간(단위%) -> 시스템콜 호출에 의해 사용되는 CPU비율 *sy의 CPU가 높을 경우 : truss 명령어로 어떤 시스템 콜이 수행중인지 확인가능* |
| id (idel)   | 사용가능한 CPU의 시간율 id = 100 - (us+sy)                   |
| wa (wait)   | 디스크 혹은 기타 io작업으로 인해 CPU가 대기하는 시간비율     |

 

## 예시

**1. [간격]으로 [횟수] 만큼 출력 : vmstat 2 5**



![img](https://blog.kakaocdn.net/dn/n8wxy/btqD1q8RGYT/zFk5kSgKL3rsxRfbosppiK/img.png)2초 간격으로 5개만 출력



**2. active/inactivate로 표시 : vmstat -a**



![img](https://blog.kakaocdn.net/dn/QD2Kv/btqD0Mj2t5d/lyGlqZDWSvbeKSLFoMmqqK/img.png)



active : 사용 중인 메모리양

inact : 사용되지 않은 메모리 양

 

**3. 시간까지 표시해서 출력 : vmstat -t**



![img](https://blog.kakaocdn.net/dn/cGQ5PK/btqD1N3O76a/Ltyn9rpCDVxdmwLE3xPQB1/img.png)



**4. 디스크 사용량 : vmstat -d** 



![img](https://blog.kakaocdn.net/dn/b1xv1o/btqD4TBiWCE/kUp4VFhn9SGfC0K6l82n01/img.png)



디스크명 : xvda

reads 필드 / wirtes 필드

| total   | 성공한 모든 읽기/쓰기 작업개수              |
| ------- | ------------------------------------------- |
| merged  | 하나의 io로 묶은 읽기/쓰기 작업수           |
| sectors | 성공적으로 읽은/쓴 섹터수                   |
| ms      | 읽기/쓰기 작업을 하는데 소요된 시간(밀리초) |

io필드

| cur  | 현재 수행중인 io수              |
| ---- | ------------------------------- |
| sec  | io를 수행하는데 소요된 시간(초) |

 

**3) mpstat**

CPU time을 CPU별로 측정
CPU별로 불균형한 상태 확인



![img](https://blog.kakaocdn.net/dn/qmUTz/btqDvZX6vdQ/suqvkbDlJ069PKbASMK1cK/img.png)



**4) pidstat
**

TOP이랑 비슷하지만 지속적으로 변화하는 상황



![img](https://blog.kakaocdn.net/dn/bUzUff/btqDvxVaP7f/J4TYXRF89Lr3je2aMepzJ0/img.png)



**5) sar (Systemc Activity Reprot)**



![img](https://blog.kakaocdn.net/dn/4lvTd/btqDwdWcFll/qNIvoJVel9iFHLWfLMVSAK/img.png)



 

 

**+kill 명령어**

프로세스 종료 명령어

사용포맷 : kill [옵션명 or 옵션번호] PID

그 중에서

옵션번호 9 : 프로세스 죽이기 (SIGKILL)

옵션번호 15 : 소프트웨어 안전종료(SIGTERM)

ex) 

kill -9 PID : 프로세스 번호로 강제종료 --> 작업중인 모든 데이터를 저장하지 않고 종료

kill -15 PID : 프로세스 번호로 안전종료 --> 메모리상에 있는 데이터 저장한 후 종료



# 3. iostat : 디스크 입출력 모니터링

iostat 명령은 CPU의 상태와 디스크 입출력에 대한 정보를 모니터링 합니다. iostat 명령으로 물리적 디스크 간의 입/출력 균형을 더 잘 맞추기 위해 시스템 구성을 변경하는 데 사용할 수 있는 보고서를 생성합니다. 시스템의 과부하나 문제를 확인하기 위해 사용 됩니다.

 

아무 옵션 없이 iostat을 입력하면 CPU와 디스크 입출력에 대한 통계를 아래와 같이 동시에 볼 수 있습니다. 

 



![img](https://blog.kakaocdn.net/dn/EBHXw/btraGcxPO9W/kBW4XBlNtmdH4RXk1ifHpk/img.png)



 

#### **CPU 관련 정보**

|             | 설명                                                         |
| ----------- | ------------------------------------------------------------ |
| **%user**   | **Application 같은 user level에서의 CPU 사용량**             |
| **%nice**   | **Nice 우선순위를 갖는 Application (user level)의 CPU 사용량** |
| **%system** | **Kernel 같은 System level에서의 CPU 사용량**                |
| **%iowait** | **미해결 I/O 작업이 완료되기를 기다리는 동안 CPU가 소비한 시간. I/O 완료를 기다리는 시간.**  **해당 CPU가 IDLE 상태(즉, 작업을 실행하지 않음)이고 해당 CPU에 예약된 작업에서 요청한 미해결 디스크 I/O 작업이 최소한 하나 있었던 시간 ( 해당 I/O 요청을 생성할 때).**  **참조 : https://veithen.io/2013/11/18/iowait-linux.html** |
| **%steal**  | **하이퍼바이저가 다른 가상 프로세서에 서비스를 제공하는 동안 가상 CPU가 비자발적으로 대기한 시간의 백분율** |
| **%idle**   | **CPU가 유휴 상태이고 시스템에 처리되지 않은 디스크 I/O 요청이 없는 시간의 백분율** |

 

#### **디스크 입출력에 대한 정보**

|                    | **설명**                                                     |
| ------------------ | ------------------------------------------------------------ |
| **device**         | **/dev 디렉토리에 나열된 장치(또는 파티션)들**               |
| **tps**            | **transfers per seconds. 초당 전송 (장치에 대한 IO 요청)률. 여러 논리적 요청을 장치에 대한 단일 I/O 요청으로 결합할 수 있음. 전송 크기가 불확실함.** |
| **KB_read/s**      | **장치에서 읽은 데이터의 양을 초당 블록 수(kilobytes, megabytes)로 표시. 블록은 섹터와 동일하므로 크기가 512바이트임.** |
| **KB_wrtn/s**      | **장치에 기록된 데이터의 양을 초당 블록 수(kilobytes, megabytes)로 계산하여 표시** |
| **KB_read**        | **읽은 총 블록 수(kilobytes, megabytes)**                    |
| **KB_wrtn**        | **기록한 총 블록 수 (\**kilobytes, megabytes)\****           |
| ***\*%util\****    | **/proc/diskstats filed #10) 장치에 I/O 요청이 발행된 CPU 시간의 백분율(장치의 대역폭 사용률). 이 값이 100%에 가까울 때 장치 포화가 발생합니다.  Percentage of CPU time during which I/O requests were issued to the device (bandwidth utilization for the device). Device saturation occurs when this value is close to 100%.** |
| ***\*await\****    | ***\*/proc/diskstats filed #4)\** 처리할 장치에 발행된 I/O 요청의 평균 시간(밀리초)입니다. 여기에는 대기열의 요청에 소요된 시간과 해당 요청을 처리하는 데 소요된 시간이 포함됩니다.  The average time (in milliseconds) for I/O requests issued to the device to be served. This includes the time spent by the requests in queue and the time spent servicing them.** |
| ***\*avgrq-sz\**** | **장치에 발행된 요청의 평균 크기(섹터)입니다 The average size (in sectors) of the requests that were issued to the device.** |
| ***\*avgqu-sz\**** | ***\*/proc/diskstats filed #11\** 장치에 발행된 요청의 평균 대기열 길이입니다. The average queue length of the requests that were issued to the device.** |

 

 

 

#### **옵션들**

| **명령**                                                     |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| **-c**                                                       | ***\*CPU 사용량 통계  \****![img](https://blog.kakaocdn.net/dn/sxHHO/btra33zDe2D/7CiSerXTs8ocV1lER8MTI1/img.png) |
| **-d**                                                       | ***\*디스크 IO 통계  \****![img](https://blog.kakaocdn.net/dn/cdlEPf/btraVFS54Yt/MUb95NrnFxwyPaFWTz3rI1/img.png) |
| **-g group_name ( device [...] \| ALL }**                    | **장치 그룹에 대한 통계를 표시합니다. iostat 명령은 목록의 각 개별 장치에 대한 통계를 보고한 다음 group_name으로 표시되고 목록의 모든 장치로 구성된 그룹에 대한 전역 통계 행을 보고합니다. ALL 키워드는 시스템에서 정의한 모든 블록 장치가 그룹에 포함되어야 함을 의미합니다.  Display statistics for a group of devices. The iostat** **command reports statistics for each individual device in** **the list then a line of global statistics for the group** **displayed as group_name and made up of all the devices in** **the list. The ALL keyword means that all the block devices** **defined by the system shall be included in the group.** |
| **-H**                                                       | **이 옵션은 -g 옵션과 함께 사용해야 하며 그룹의 개별 장치에 대한 통계가 아니라 그룹에 대한 전역 통계만 표시됨을 나타냅니다.  This option must be used with option -g and indicates that** **only global statistics for the group are to be displayed,** **and not statistics for individual devices in the group.** |
| **-h**                                                       | ***\*--human 과 동일  \****![img](https://blog.kakaocdn.net/dn/coWUDJ/btraP82NfA4/7VSQZe04ipxsOgg5mdK670/img.png) |
| **--human**                                                  | **사람이 읽을 수 있는 형식의 인쇄 크기(예: 1.0k, 1.2M 등) 이 옵션으로 표시되는 단위는 메트릭과 관련된 다른 기본 단위(예: 킬로바이트, 섹터...)를 대체합니다.  Print sizes in human readable format (e.g. 1.0k, 1.2M,** **etc.) The units displayed with this option supersede any** **other default units (e.g. kilobytes, sectors...)** ***\*associated with the metrics.  \****![img](https://blog.kakaocdn.net/dn/blbT7T/btraZNcb4sR/w1IUlXbVKPKBUqkYRa5pg1/img.png) |
| **-j { ID \| LABEL \| PATH \| UUID \| ... } [device [...] \| ALL ]** | **영구 장치 이름을 표시합니다. 키워드 ID, LABEL 등은 영구 이름의 유형을 지정합니다. 이러한 키워드는 제한되지 않으며 필수 영구 이름이 있는 디렉토리가 /dev/disk에 있어야 한다는 전제 조건만 있습니다. 선택적으로 선택한 영구 이름 유형에 여러 장치를 지정할 수 있습니다.   Display persistent device names. Keywords ID, LABEL, etc.** **specify the type of the persistent name. These keywords a****re not limited, only prerequisite is that directory with** **required persistent names is present in /dev/disk.** **Optionally, multiple devices can be specified in the** **chosen persistent name type.** |
| **-k**                                                       | ***\*초당 킬로바이트 단위로 통계를 표시합니다. Display statistics in kilobytes per second.  \****![img](https://blog.kakaocdn.net/dn/mwOcm/btraVTEgr4S/NeoL9RZR4n1YkCufFuDkd1/img.png) |
| **-m**                                                       | ***\*초당 메가바이트 단위로 통계를 표시합니다 Display statistics in megabytes per second.  \****![img](https://blog.kakaocdn.net/dn/dMgTt4/btra34R0Tud/pThOsW9ESoxJrf4Zis9YPK/img.png) |
| **-N**                                                       | **모든 장치 매퍼 장치에 대해 등록된 장치 매퍼 이름을 표시합니다. LVM2 통계를 보는 데 유용합니다. Display the registered device mapper names for any device** **mapper devices. Useful for viewing LVM2 statistics.** |
| **-o JSON**                                                  | **통계를 JSON(Javascript Object Notation) 형식으로 표시합니다. JSON 출력 필드 순서는 정의되지 않았으며 향후 새 필드가 추가될 수 있습니다.  Display the statistics in JSON (Javascript Object Notation) format. JSON output field order is undefined, and new fields may be added in the future.** |
| **-p [ ( device [...] \| ALL } ]**                           | **시스템에서 사용하는 블록 장치 및 모든 해당 파티션에 대한 통계를 표시합니다. 명령줄에 장치 이름을 입력하면 해당 장치와 모든 파티션에 대한 통계가 표시됩니다. 마지막으로 ALL 키워드는 사용된 적이 없는 것을 포함하여 시스템에서 정의한 모든 블록 장치 및 파티션에 대한 통계가 표시되어야 함을 나타냅니다. 이 옵션 앞에 -j 옵션이 정의되어 있으면 명령줄에 입력한 장치를 선택한 영구 이름 유형으로 지정할 수 있습니다.  Display statistics for block devices and all their partitions that are used by the system. If a device name is entered on the command line, then statistics for it and all its partitions are displayed. Last, the ALL keyword indicates that statistics have to be displayed for all the block devices and partitions defined by the system, including those that have never been used. If option -j is defined before this option, devices entered on the command line can be specified with the chosen persistent name type.** |
| **-s**                                                       | ***\*80자 너비의 화면에 맞는 짧은(좁은) 버전의 보고서를 표시합니다. Display a short (narrow) version of the report that should fit in 80 characters wide screens.  \****![img](https://blog.kakaocdn.net/dn/XTT1s/btra6I2fRdh/1ohLNoUAqUyWwhMoxx4g8K/img.png) |
| **-t**                                                       | ***\*표시된 각 보고서의 시간을 인쇄합니다. 타임스탬프 형식은 S_TIME_FORMAT 환경 변수의 값에 따라 달라질 수 있습니다. Print the time for each report displayed. The timestamp format may depend on the value of the S_TIME_FORMAT environment variable.  \****![img](https://blog.kakaocdn.net/dn/Oc034/btra8nKjS0w/h6WValIT7XLHV5kdav6s51/img.png) |
| **-V**                                                       | **Print version number then exit.**                          |
| **-x**                                                       | ***\*확장 통계를 표시합니다. Display extended statistics.  \****![img](https://blog.kakaocdn.net/dn/bLSG6D/btra10oPYxZ/Oic84t5oeEBsG0FMZQmRP1/img.png) |
| **-y**                                                       | **지정된 간격으로 여러 레코드를 표시하는 경우 시스템 부팅 이후 통계가 포함된 첫 번째 보고서를 생략합니다. Omit first report with statistics since system boot, if displaying multiple records at given interval.** |
| **-z**                                                       | **샘플 기간 동안 활동이 없었던 모든 장치에 대한 출력을 생략하도록 iostat에 지시합니다. Tell iostat to omit output for any devices for which there was no activity during the sample period.** |

 

 

연관된 환경변수

| 환경변수            | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| **POSIXLY_CORRECT** | **이 변수가 설정되면 전송 속도는 기본 1K 블록 대신 512바이트 블록으로 표시됩니다. When this variable is set, transfer rates are shown in** **512-byte blocks instead of the default 1K blocks.** |
| **S_COLOR**         | **기본적으로 통계는 출력이 터미널에 연결될 때 컬러로 표시됩니다. 이 변수를 사용하여 설정을 변경합니다. 이 변수에 가능한 값은 never, always 또는 auto입니다(후자는 기본 설정과 동일함).  값을 표시하는 데 사용된 색상(빨간색, 노란색 또는 기타 색상)은 단순히 색상 때문에 어떤 종류의 문제도 나타내지 않습니다. 다른 값 범위만 나타냅니다.  By default statistics are displayed in color when the** **output is connected to a terminal. Use this variable to** **change the settings. Possible values for this variable are** **never, always or auto (the latter is equivalent to the** **default settings).** ** Please note that the color (being red, yellow, or some** **other color) used to display a value is not indicative of** **any kind of issue simply because of the color. It only** **indicates different ranges of values.** |
| **S_COLOR_SGB**     | **터미널에 통계를 표시하는 데 사용되는 색상 및 기타 속성을 지정합니다. 그 값은 H=31;1:I=32;22:M=35;1:N=34;1:Z=34;22로 기본 설정되는 기능의 콜론으로 구분된 목록입니다. 지원되는 기능은 다음과 같습니다.   H= 75% 이상의 백분율 값에 대한 SGR(Select Graphic Rendition) 하위 문자열.   I= 장치 이름에 대한 SGR 하위 문자열.  M= 50% ~ 75% 범위의 백분율 값에 대한 SGR 하위 문자열.  N= 0이 아닌 통계 값에 대한 SGR 하위 문자열.  Z= 0 값에 대한 SGR 하위 문자열.  Specify the colors and other attributes used to display** **statistics on the terminal. Its value is a colon-** **separated list of capabilities that defaults to** **H=31;1:I=32;22:M=35;1:N=34;1:Z=34;22. Supported** **capabilities are:**   **H=   SGR (Select Graphic Rendition) substring for** **percentage values greater than or equal to 75%.**  **I=   SGR substring for device names.**  **M=   SGR substring for percentage values in the range** **from 50% to 75%.**  **N=   SGR substring for non-zero statistics values.**  **Z=   SGR substring for zero values.** |
| **S_TIME_FORMAT**   | **이 변수가 존재하고 그 값이 ISO이면 보고서 헤더의 날짜를 인쇄할 때 zcurrent 로케일이 무시됩니다. iostat 명령은 대신 ISO 8601 형식(YYYY-MM-DD)을 사용합니다. -t 옵션으로 표시되는 타임스탬프는 ISO 8601 형식도 준수합니다.  If this variable exists and its value is ISO then the** **zcurrent locale will be ignored when printing the date in** **the report header. The iostat command will use the ISO** **8601 format (YYYY-MM-DD) instead. The timestamp displayed** **with option -t will also be compliant with ISO 8601** **format.** |

 

------

#### **사용예**

**iostat :** Display a single history since boot report for all CPU and Devices.

**iostat -d 2 :** Display a continuous device report at two second intervals.

**iostat -d 2 6 :** Display six reports at two second intervals for all devices.

**iostat -x hda hdb 2 6 :** Display six reports of extended statistics at two second intervals for devices hda and hdb.

**iostat -p sda 2 6 :** Display six reports at two second intervals for device sda and all its partitions (sda1, etc.)

 

**iostat [ -c ] [ -d ] [ -N ] [ -n ] [ -h ] [ -k | -m ] [ -t ] [ -V ] [ -x ] [ -z ] [** *device* **[...] | ALL ] [ -p [** *device* **[,...] | ALL ] ] [** *interval* **[** *count* **] ]**





# 4. netstat : 네트워크 상태 모니터링

네트워크 관련 정보를 보는데 일반적으로 사용하는 범용 유틸리티입니다

 ***tcp / udp / 소켓의 네트워크 연결 목록을 확인할 때 주로 사용합니다.***

------

*** netstat -a ( -a 옵션을 주어서 모든 연결 목록을 출력합니다 )**

 



![img](https://blog.kakaocdn.net/dn/dwmSN7/btqvJKNBSW9/agO4MQRsTXZPlodL95Onl1/img.png)

![img](https://blog.kakaocdn.net/dn/VETf6/btqvImzIam0/t5OXkAC2ocxgeXMqYqxOk0/img.png)



뭐라고 뭐라고 막 많이 출력되었습니다.

해당하는 필드가 의미하는 것이 무엇인지 파악이 필요하겠죠? 뭐든지 알기 전까진 어렵지만 알고 나면 쉽습니다.

알아봅시다.

 

| 필 드 명            | 의 미                                                        |
| ------------------- | ------------------------------------------------------------ |
| **Proto**           | 사용중인 프로토콜을 표시해주는 필드입니다. ( ex. tcp/udp )   |
| **Recv-Q**          | 수신 소켓 버퍼에 존재하는 바이트 수를 표시해주는 필드입니다. |
| **Send-Q**          | 송신 소켓 버퍼에 존재하는 바이트 수를 표시해주는 필드이며  반대편 peer socket에 전송되지 못한 것을 의미합니다. |
| **Local Address**   | 로컬 주소 표시 필드                                          |
| **Foreign Address** | 상대편 주소 표시 필드                                        |
| **state**           | 현재 연결의 상태를 표시해 주는 필드입니다.                   |

 

 

 

*** netstat -nr ( -nr 옵션을 주어서 라우팅 테이블 상태를 출력합니다.)**

 



![img](https://blog.kakaocdn.net/dn/uvP5c/btqvJUid9oy/wKPaVvZRZJowqwkTjkKkFK/img.png)



route 명령어를 사용했을 때와 동일한 결과를 출력해줍니다.

기본적으로 -r 옵션만 주어서 출력을 할 수 있지만 -n 옵션을 주어서 호스트 찾기 안 함으로 빠른 결과를 출력할 때

사용합니다.

 

여기서 의미하는 필드의 값도 알아봅시다.

 

| 필 드 명    | 의 미                                                        |
| ----------- | ------------------------------------------------------------ |
| **Gateway** | 라우팅 항목에서의 gateway를 표시합니다.                      |
| **Genmask** | 라우팅 항목의 netmask 를 표시합니다.                         |
| **Flags**   | 라우팅 경로에 관한 여러 플래그를 표시합니다. **U** : 인터페이스가 UP 인 상태 **H** : 라우팅 경로를 통해 호스트로의 연결 **G** : 게이트웨이의 라우트 **D** : 라우트가 재지정되어 동적으로 생성 **M** : 라우팅 경로가 ICMP 리다이렉트 메시지를 통해 수정되었을 경우   최대 세크먼트 크기 |
|             |                                                              |
| **MSS**     |                                                              |
| **Window**  | 원격에서 한 번에 보내는 데이터의 수신량                      |
| **irtt**    | initial round trip time 으로, 0은 초기 설정값을 사용한다는 의미 |
| **Ifce**    | 네트워크 인터페이스                                          |

 

 

 

*** netstat -at ( -at 옵션을 부여하여 tcp 연결만 모두 출력할 때 사용합니다. )**

 



![img](https://blog.kakaocdn.net/dn/DvsCN/btqvJ5X9unY/Yc2uu22Xh2WLv2WvSnd5CK/img.png)



다음과 같이 tcp 연결의 모든 상태를 출력합니다.

 

*** netstat -au ( -au 옵션을 부여하여 udp 연결만 모두 출력할 때 사용합니다. )**

 



![img](https://blog.kakaocdn.net/dn/3B2Pc/btqvIlt7S8i/GiUgI3pM5TzfpcMXrymWnK/img.png)



tcp와 반대로 udp 연결의 모든 상태를 출력합니다.

해당 필드 값은 위에 참고해주세요.

 

*** netstat -nl ( -nl 옵션을 부여하여 호스트 찾기 안 함으로 빠르게 Linsten 인 상태 모두를 출력할 때 사용 )**

 



![img](https://blog.kakaocdn.net/dn/copwRz/btqvIkvc6qt/zDwkFLtkF7UldeVYCTyJGK/img.png)



여기서 응용하면 -t 옵션을 추가하여 -ntl 옵션으로 tcp의 Linsten 인 상태 모두를 출력할 수도 있습니다.

반대로 -u 옵션을 추가하여 -nul 옵션으로 udp의 Listen 인 상태 모두를 출력도 가능합니다.

 

여기서 상태를 나타내는 **state의** 필드 값에 대해서 알아봅시다.

| 필 드 값                                | 의 미                                                        |
| --------------------------------------- | ------------------------------------------------------------ |
| **LISTEN**                              | 연결이 가능하도록 관련 데몬이 떠있으며 연결이 가능함을 의미합니다. |
| **SYN-SENT**                            | 연결을 요청한 상태를 의미합니다.                             |
| **SYN_RECEIVED**                        | 연결요구에 의한 응답을 준 후에 확인메시지를 기다리고 있는 상태를 의미. |
| **ESTABLISHED**                         | 위의 3단계 연결과정이 모두 종료된 후에 연결이 완료된 상태를 의미. |
| **FIN-WAIT, CLOSE-WAIT,** **FIN-WAIT2** | 연결 종료를 위해 종료 요청을 받은 후의 종료 과정을 의미.     |
| **CLOSING**                             | 전송된 메시지가 유실된 상태를 의미합니다.                    |
| **TIME-WAIT**                           | 연결종료 후에 한동안 유지하고 있는 상태를 의미합니다.        |
| **CLOSED**                              | 연결이 완전히 종료된 상태를 의미합니다.                      |

state의 해당 필드 값이 의미하는 뜻이 무엇이지 파악하고 있는 것이 troubleshooting 할 때 굉장히 중요한 부분이니 꼭 체크하고 넘어가시기 바랍니다.



# 5. sar : CPU 사용률, 메모리 사용률, 디스크 I/O 및 네트워크 트래픽과 같은 리눅스 시스템의 성능 지표를 일정한 시간 간격으로 수집합니다. 

\- 기본적으로 sar 명령어를 입력하였을 경우 보여지는 값은 CPU사용 정보입니다.
  \* %user : user mode 에서 작동한 CPU 가동률
  \* %sys : kernel mode에서 작동한 CPU 가동률
  \* %idle : idle 상태로 있었던 CPU 대기율
  \* %iowait : io wait 상태로 있었던 CPU 대기율

\- 실시간으로 정보 보기는 "sar [간격] [인터벌] 형식으로 입력합니다.
 ex) sar 3 10 : 3초 간격으로 10개의 데이터 값을 출력해 줍니다. 

\- 특정 날짜의 sar 정보 확인은 아래 명령어로 확인 가능합니다. (1달치 정보 조회 가능)
  해당 옵션은 다른 옵션과 조합하여 CPU 사용 정보 이외의 정보 조회도 가능합니다. 
  ex) sar -f /var/log/sa/sa01   -> 1일자 CPU 사용 정보 정보 출력

#### **[옵션 활용을 통한 시스템 모니터링]**

**-b** : 버퍼의 액티비티 측정. I/O와 transfer의 통계를 백분율로 출력합니다.
   \* tps : 디스크에서 발생되어진 초당 전송량. 즉 디스크에 요청한 I/O양.
   \* rtps : 디스크로부터 발생된 초당 읽기 총 요청 횟수
   \* bread/s : 드라이브 안의 블럭에서 초당 읽은 데이터의 총합.
   \* bwrtn/s : 드라이브 안의 블럭에서 초당 쓰여진 데이터의 총합.
![sar-b.JPG](https://cafe24.zendesk.com/hc/article_attachments/10070655918489/sar-b.JPG)

**-q** : 실행 대기 큐에 있는 프로세스를 보여줍니다. 시스템의 load avarage를 나타냅니다.
   \* runq-sz : 각 프로세스 대기 시간
   \* plist-sz : 전체 프로세스 수
   \* ldavg-1 : 기준 시간 이전 1분간 평균 작업 부하 정보
   \* ldavg-5 : 기준 시간 이전 5분간 평균 작업 부하 정보
   \* ldavg-15 : 기준 시간 이전 15분간 평균 작업 부하 정보
![sar-q.JPG](https://cafe24.zendesk.com/hc/article_attachments/10071330280473/sar-q.JPG)

**-r** : 메모리, 스왑 공간의 이용 통계를 출력합니다.
   \* kbmemfree : 사용가능한 총 메모리의 양(k/bytes)
   \* kbmemused : 사용중인 총 메모리의 양(k/bytes), 커널에서 사용중인 메모리는 제외
   \* %memused : 사용된 메모리의 %양
   \* kbmemshrd : 시스템에서 공유메모리로 사용된 총 메모리의 양(k/bytes)
   \* kbbuffers : 커널에서 buffer 메모리로 총 사용된 메모리의 양(k/bytes)
   \* kbcached : 커널에서 cache data로 사용된 총 메모리의 양(k/bytes)
   \* kbswpfree : 사용가능한 스왑 공간의 양(k/bytes)
   \* kbswpused : 사용된 스왑 공간의 양(k/bytes)
   \* %swpused : 사용된 스왑 공간의 %양
![sar-r.JPG](https://cafe24.zendesk.com/hc/article_attachments/10071491562521/sar-r.JPG)







## 시스템 상태 확인하기

- fsck : 파일 시스템 오류 확인
- du : 디스크 사용량 출력
- df





# 로그 파일과 시스템 모니터링

리눅스에서 로그파일(Log file)은 시스템의 동작 상태나 사용자 활동 등을 기록하는 파일로, 시스템 운영과 문제점 해결 등에 필수적으로 활용됩니다.

## 로그파일의 위치 및 종류

리눅스에서 로그 파일은 일반적으로 /var/log 디렉터리에 저장되며, 시스템 로그(dmesg, messages, syslog), 인증 로그(auth, auth.log), 웹 서버 로그(access, error), 애플리케이션 로그 등 다양한 종류의 로그가 존재합니다.

## 로그파일 분석

리눅스에서 로그 모니터링(Log monitoring)은 로그 파일을 실시간으로 분석하여, 시스템의 문제를 조기에 감지하고 대응하는 것을 말합니다. 대표적인 로그 모니터링 도구로는 logwatch, logrotate, syslog-ng, rsyslog, ELK 스택 등이 있으며, 이들 도구를 이용하여 로그 데이터를 수집, 필터링, 분석, 시각화할 수 있습니다. 이를 통해 시스템의 문제를 빠르게 파악하고 대응할 수 있습니다.



## 패킷 분석 및 디버깅 도구

리눅스에서는 다양한 패킷 분석 및 디버깅 도구를 제공하여 네트워크 트래픽 분석, 문제점 진단 등에 활용됩니다. 대표적인 도구로는 tcpdump, Wireshark, strace, gdb 등이 있습니다.

## tcpdump

tcpdump는 네트워크 인터페이스에서 전송되는 패킷을 캡처하고 분석하는 명령어 기반 도구입니다. 기본적으로 모든 패킷을 캡처하므로, 필요한 패킷만 추출하려면 BPF(Berkeley Packet Filter) 필터를 이용해야 합니다. 예를 들어, 다음 명령어는 eth0 인터페이스에서 포트 80으로 전송되는 HTTP 패킷만 캡처합니다.

```
sudo tcpdump -i eth0 port 80
```

## Wireshark

Wireshark는 GUI 기반 패킷 분석 도구로, tcpdump와 유사하게 패킷을 캡처하고 분석할 수 있습니다. GUI 환경에서 패킷을 시각화하여 분석할 수 있으며, 다양한 필터를 제공하여 원하는 패킷만 추출할 수 있습니다.

## strace

strace는 프로세스가 시스템 호출(system call)을 할 때마다 호출 정보를 출력하는 도구입니다. 이를 통해 프로그램의 동작을 추적하고, 문제가 발생한 시점을 파악할 수 있습니다. 예를 들어, 다음 명령어는 ls 명령어 실행 시 호출되는 시스템 호출 정보를 출력합니다.

```
sudo strace ls
```

## gdb

gdb는 C/C++ 프로그램 디버깅에 사용되는 명령어 기반 도구입니다. 프로그램 실행 중에 원하는 지점에서 중지하고, 변수 값 등을 확인할 수 있습니다. gdb를 이용해 프로그램이 비정상 종료되는 원인을 찾을 수 있습니다.