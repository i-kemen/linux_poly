---
layout : home
---
# <32장 위치 매개변수>



## 1. 커맨드라인 항목 접근

쉘은 **위치 매개변수**라는 변수의 집합을 제공 -> 커맨드라인 명령의 개별 요소들을 가지고 있으며 변수들은 0~9까지의 이름을 붙인다. 

<ex> 변수 $0부터 $9까지의 값을 표시하는 스크립트

\#! / bin/ bash 

posit-param : script to view command line parameters 

echo "

\ \$0 = $0

 \ $1 = $1

 \ $2 = $2
 \  \$3 = $3 
 \ $4 = $4 
 \ \$5 = $5 
\\ $6 = $6 
\ $7 = $7 
\\$8 = $8 
\\$9 = $9"



<1> 커맨드라인 인자 없이 출력하면 아래처럼 나옴
-> 인자가 없는 경우에도 $0은 항상 커맨드라인의 첫번째 항을 가짐 = 실행되고 있는 프로그램의 경로

[me@linuxbox ~]$ posit-param 

$0 = /home/me/bin/posit-param 

$1 = 

$2 = 

$3 = 

$4 = 

$5 = 

$6 = 

$7 = 

$8 = 

$9 =



<2> 커맨드라인 인자를 입력하고 실행해보자

[me@linuxbox ~]$ posit-param 

$0 = /home/me/bin/posit-param a b c d

$1 = a

$2 = b

$3 = c

$4 = d

$5 = 

$6 = 

$7 = 

$8 = 

$9 =



## 2. 인자 수 확인

쉘은 커맨드라인의 인자 수를 넘겨주는 변수 $#을 제공한다.
<ex>
echo " Number of arguments: $# 
\ $0 = $0 
\ $1 = $1 
\ $2 = $2 
\ $3 = $3 
\ $4 = $4 
\ $5 = $5 
\ $6 = $6 
\ $7 = $7 
\ $8 = $8
\ $9 = $9 



결과는 이와 같다. 

[me@linuxbox ~]$ posit-param a b c d 
**Number of arguments: 4** 
$0 = / home/ me / bin/ posit-param 
$1 = a 
$2 = b 
$3 = c
$4 = d 
$5 = 
$6 = 
$7 = 
$8 = 
$9 =



### 3. shift - 다수의 인자에 접근 

수많은 인자가 주어진다면? 어떻게 처리할 것인가?

스크립트가 `shift` 명령어를 만나면 커맨드라인 매개변수를 앞으로 차례대로 한 칸씩 당깁니다.

즉 `$3` -> `$2`가 되고,
`$2` -> `$1`가 되며,
기존의 `$1`의 값은 사라집니다.

이를 응용하면 매개변수의 개수가 얼마나 될지 모를 때 반복해서 참조하기 유용합니다.

```bash
$ cat test1
#!/bin/bash
count=1
while [ -n "$1" ]
do
        echo "parameter #$count : $1"
        (( count = count + 1 ))
        shift
done

$ ./test1 A B C D E
parameter #1 : A
parameter #2 : B
parameter #3 : C
parameter #4 : D
parameter #5 : E
```

> **코드 리뷰**
>
> - `while` 문은 `shift`로 매개변수가 앞으로 하나씩 당겨지다가 아무런 값이 존재하지 않게 되면 종료됩니다.
> - `count` 변수는 `1`부터 매개변수의 개수까지 `1`씩 증가합니다.
> - `shift`를 통해 매개변수가 하나씩 앞으로 당겨지면서 `$1`이 되기 때문에 계속해서 `$1`을 참조하면 됩니다.



### cf) 간단한 응용프로그램



### 4. 쉘 함수에서 위치 매개변수의 사용

인자를 전달하기 위해 쉘 스크립트에 위치 매개변수를 사용했던 것처럼 쉘 함수에 인자를 전달할 수 있다. 

<ex> 쉘 함수 file_info를 포함한 스크립트가 파일명 인자와 함께 함수를 하도록 작성

file_info () {

file_info: function to display file information 

if [ [ -e $1 ]] ; then 

echo -e "\nFile Type :" 
file $1 echo -e "\ nFile Status: "
stat $1 
else 
echo 
"$FUNCNAME : usage : $FUNCNAME file" >&2 
return 1 
fi 
} 



위 처럼 작성하면 해당 인자가 함수에 전달된다.

**이때 앞선 예시에서 PROGNAME 변수가 쉘 변수 FUNCNAME으로 변경된다!**

쉘은 현재 실행된 쉘 함수를 계속 추적하여 자동으로 이 변수를 갱신한다. 

$0은 항상 커맨드라인 첫 번째에 경로명(즉, 프로그램명)을 가지지만 우리가 예측한 것처럼 쉘 함수명은 가지고 있지 않다.



